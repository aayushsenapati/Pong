<!DOCTYPE html>
<html>

<head>
    <title>Join Room</title>
</head>

<body>
    <canvas id="gameCanvas"> </canvas>
    <div id="root"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react@17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babel-standalone@6.26.0/babel.min.js"></script>
    <script>
        const socket = io();
    </script>
    <script type="text/babel">
        function Join(props) {
            return (
                <div>
                    <label htmlFor="room-id">Enter Room ID:</label>
                    <input type="text" id="room-id" name="room-id" />
                    <button
                        onClick={() =>
                            props.joinRoom(document.getElementById("room-id").value)
                        }
                    >
                        Join Room
                    </button>
                    <button onClick={() => props.createRoom()}>Create Room</button>
                </div>
            );
        }

        function Game() {
            let canvas = document.getElementById("gameCanvas");
            let engine = new BABYLON.Engine(canvas, true);


            let createScene = function () {

                let scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

                let material = new BABYLON.StandardMaterial("material", scene);
                material.diffuseColor = new BABYLON.Color3(255, 1, 1);

                // Light
                let light = new BABYLON.PointLight(
                    "pointLight",
                    new BABYLON.Vector3(0, 10, 0),
                    scene
                );
                light.intensity = 0.8;

                // Create a plane
                let plane = BABYLON.MeshBuilder.CreatePlane(
                    "plane",
                    { size: 12 },
                    scene
                );
                plane.position.y = 0;
                plane.rotation.x = Math.PI / 2;

                // Create paddles
                let leftPaddle = BABYLON.MeshBuilder.CreateBox(
                    "leftPaddle",
                    { height: 0.5, width: 0.1, depth: 2 },
                    scene
                );
                leftPaddle.material = material;
                let rightPaddle = BABYLON.MeshBuilder.CreateBox(
                    "rightPaddle",
                    { height: 0.5, width: 0.1, depth: 2 },
                    scene
                );
                leftPaddle.position.x = -5.95;
                rightPaddle.position.x = 5.95;
                leftPaddle.position.y = rightPaddle.position.y = 0.25;

                // Create ball
                let ball = BABYLON.MeshBuilder.CreateSphere(
                    "ball",
                    { diameter: 0.5 },
                    scene
                );
                ball.position.y = 0.5;

                let leftWall = BABYLON.MeshBuilder.CreateBox(
                    "leftWall",
                    { height: 0.5, width: 0.1, depth: 12 },
                    scene
                );
                leftWall.position.x = -6.05;

                let rightWall = BABYLON.MeshBuilder.CreateBox(
                    "leftWall",
                    { height: 0.5, width: 0.1, depth: 12 },
                    scene
                );
                rightWall.position.x = 6.05;

                // Camera
                let camera = new BABYLON.FreeCamera(
                    "camera",
                    new BABYLON.Vector3(-9, 3, 0),
                    scene
                );
                camera.rotation.y = Math.PI / 2; // rotate the camera to face the other paddle
                camera.rotation.x = Math.PI / 6;

                // Attach the camera to the left paddle
                //camera.parent = leftPaddle;
                camera.position = new BABYLON.Vector3(-12, 7, 0); // adjust the camera position to be behind the left paddle

                // Set physics properties
                let physicsPlugin = new BABYLON.CannonJSPlugin();
                scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), physicsPlugin);

                plane.physicsImpostor = new BABYLON.PhysicsImpostor(
                    plane,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 0.2 },
                    scene
                );
                leftPaddle.physicsImpostor = new BABYLON.PhysicsImpostor(
                    leftPaddle,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 10000, restitution: 0.1, ignoreGravity: true },
                    scene
                );
                leftWall.physicsImpostor = new BABYLON.PhysicsImpostor(
                    leftWall,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 0.1, ignoreGravity: true },
                    scene
                );
                rightWall.physicsImpostor = new BABYLON.PhysicsImpostor(
                    rightWall,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 0.1, ignoreGravity: true },
                    scene
                );
                rightPaddle.physicsImpostor = new BABYLON.PhysicsImpostor(
                    rightPaddle,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 10000, restitution: 0.1, ignoreGravity: true },
                    scene
                );
                ball.physicsImpostor = new BABYLON.PhysicsImpostor(
                    ball,
                    BABYLON.PhysicsImpostor.SphereImpostor,
                    { mass: 1, restitution: 1 },
                    scene
                );

                // Add event listener to move left paddle
                document.addEventListener("keydown", function (event) {
                    if (event.code === "KeyA" && leftPaddle.position.z < 5) {
                        leftPaddle.position.z += 0.5;
                        socket.emit("paddlePos", leftPaddle.position);
                    } else if (event.code === "KeyD" && leftPaddle.position.z > -5) {
                        leftPaddle.position.z -= 0.5;
                        socket.emit("paddlePos", leftPaddle.position);
                    }
                });
                // Create variables for ball movement
                

                socket.on("paddleReply", (data) => {

                    console.log("position received", data);
                    //rightPaddle.position.x = data._x;
                    //rightPaddle.position.y = data._y;
                    rightPaddle.position.z = -data._z;
                })
                // Move the ball
                let moveBall = function () {

                    socket.emit("getBallPos")
                    socket.on("ballReply", (data) => {
                        //console.log("ball position received", data);
                        ball.position.x=data.x
                        ball.position.z=data.z
                    })

                    /* ball.position.x += xDirection * 0.1;
                    ball.position.z += yDirection * 0.1; */

                    // Set up the collision callback for the ball

                    ball.physicsImpostor.registerOnPhysicsCollide(
                        leftPaddle.physicsImpostor,
                        function (main, collided) {
                            xDirection = 1;
                        }
                    );
                    ball.physicsImpostor.registerOnPhysicsCollide(
                        rightPaddle.physicsImpostor,
                        function (main, collided) {
                            xDirection = -1;
                        }
                    );
                    ball.physicsImpostor.registerOnPhysicsCollide(
                        leftWall.physicsImpostor,
                        function (main, collided) {
                            xDirection = 1;
                        }
                    );
                    ball.physicsImpostor.registerOnPhysicsCollide(
                        rightWall.physicsImpostor,
                        function (main, collided) {
                            xDirection = -1;
                        }
                    );

                    // Check for collisions with the walls
                    /* if (ball.position.x <= -5.75 || ball.position.x >= 5.75) {
                xDirection *= -1;
            } */
                    if (ball.position.z <= -5.75 || ball.position.z >= 5.75) {
                        yDirection *= -1;
                    }
                };

                // Start the game loop
                scene.onBeforeRenderObservable.add(function () {
                    moveBall();
                });

                return scene;
            };

            let scene = createScene();

            // Resize the canvas when the window is resized
            window.addEventListener("resize", function () {
                engine.resize();
            });

            // Start the engine
            engine.runRenderLoop(function () {
                scene.render();
            });
            return (
                <div>
                    <h1>Game</h1>
                </div>
            );
        }

        function App() {
            const [roomState, setRoomState] = React.useState("waiting");
            socket.on("startGame", () => {
                setRoomState("game");
            });
            function joinRoom(roomId) {
                if (roomId == "") return;
                console.log(roomId);
                socket.emit("joinRoom", roomId);
            }
            function createRoom() {
                socket.emit("createRoom");
            }

            return (
                <div>
                    {roomState === "waiting" ? (
                        <Join joinRoom={joinRoom} createRoom={createRoom} />
                    ) : (
                        <Game />
                    )}
                </div>
            );
        }
        ReactDOM.render(<App />, document.getElementById("root"));
    </script>

    <script>
        socket.on("roomFull", () => {
            console.log("Room is full");
        });
        socket.on("createdRoom", (roomNo) => {
            console.log(roomNo);
            document.getElementById("room-id").value = roomNo;
        });
        socket.on("roomNotFound", () => {
            console.log("Room not found");
        });
        socket.on("joinedRoom", (roomId) => {
            console.log("Joined Room ", roomId);
        });
        socket.on("userJoined", (socketId) => {
            console.log("User joined ", socketId);
        });
    </script>
</body>

</html>